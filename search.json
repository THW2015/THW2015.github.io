[{"title":"进程，线程，协程","url":"/2018/10/31/进程，线程，协程/","content":"## 什么是进程\n&nbsp;&nbsp;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n<!-- more -->\n---\n\n## 什么是线程\n&nbsp;&nbsp;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n\n---\n\n## 线程与进程的比较\n\n 1. 同一个进程中的线程共享同一内存空间，但是进程之间是独立的。\n 2. 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。\n 3. 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。\n 4. 一个进程至少有一个进程。\n 5. 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。\n 6. 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。\n 7. 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。\n 8. 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。\n 我们用更加直观的表格去展示\n \n|对比维度|多进程|多线程|总结|\n|:---:|:---|:---|:---:|\n|数据共享、同步|数据共享复杂，需要用IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势|\n|内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优|\n|创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优|\n|编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优|\n|可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优|\n|分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优|\n\n\n---\n\n## 进程与线程使用场景总结\n\n\n - 进程多用于计算密集型\n - 线程多用于IO密集型\n\n## 协程\n&nbsp;&nbsp;协程又称微线程,是一种用户态的轻量级线程，协程的调度完全由用户控制。协程不是被操作系统内核所管理，而完全是由程序所控制,协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n\n \n","tags":["操作系统"],"categories":["Java"]},{"title":"Spring Schedule","url":"/2018/09/13/Spring Schedule/","content":"## Spring Schedule\n是实现作业调度，如定时任务的一个spring系列的一个框架\n\n该框架的优点\n > * 基于注解来设置调度器\n > * 非常方便实现简单的调度\n> * 对代码不具有入侵性，非常轻量级\n\n---\n<!-- more -->\n\n### cron表达式\ncron表达式格式:秒 分 时 日 月 周 年（可选）\n\n 1. Seconds\n 2. Minutes\n 3. Hours\n 4. Day-of-Month\n 5. Month\n 6. Day-of-Week\n 7. Year(可选)\n\n| 字段名      | 允许值   |  允许的特殊字符  |\n|:---|:---|:---|\n|秒|0-59|, - * /|\n|分|0-59|, - * /|\n|小时|0-23|, - * /|\n|月内日期|1-31|, - * ? / L W C |\n|月|1-12 或者 JAN-DEC|, - * /|\n|周内日期|1-7 或者 SUN-SAT|, - * ？/ L C #|\n|年(可选)|留空，1970-2099|, - * /|\n\n特殊字符含义\n\n -  **\\*** ：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。\n -  **?**：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。\n -  **-**：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 \n -  **/**：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. \n -  **,**：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 \n -  **L**：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。\n -  **W**:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。\n -  **LW**:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 \n -  **\\#**:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\n#### 常见cron表达式\n\n 1. 0 0 2 1 * ? *   表示在每月的1日的凌晨2点调整任务\n 2. 0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业\n 3. 0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n 4. 0 0 10,14,16 * * ?   每天上午10点，下午2点，4点 \n 5. 0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时 \n\n---\n在项目中为了关闭指定时间内的订单运用到了spring schedule我们先来查看配置\n\n在applicationContext.xml(根上下文中)加入:\n`<task:annotation/>`\n\n在项目中一个task文件夹来存放相关定时任务处理逻辑\n\n\n    @Component\n    @Slf4j\n    public class CloseOrderTask {\n        @Autowired\n        IOrderService iOrderService;\n        @Scheduled(cron = \"0 */1 * * * ?\")\n        //隔一分钟执行一次\n        public void closeOrderTaskV1(){\n            log.info(\"关闭订单定时任务启动\");\n            ...//订单关闭逻辑\n            log.info(\"关闭订单定时任务结束\");\n        }\n    }\n    \n这个定时器注解配置就这样","tags":["spring"],"categories":["Java"]},{"title":"apache fileupload","url":"/2018/05/30/apache-fileupload/","content":"&nbsp;&nbsp;apache fileupload是一个文件上传包,这里简单的介绍一下他的使用方法导入包\n<!-- more -->\n\t![1.png](apache-fileupload/1.png)\n\t&nbsp;&nbsp;由于fileupload操作有大量的io操作，所以导入一个IOUtil包方便开发\n\t![2.png](apache-fileupload/2.png)\n\t&nbsp;&nbsp;导入这两个包后就可以就行文件上传的小demo\n\t&nbsp;&nbsp;首先页面代码\n\t\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n    <form action=\"/fileup/fileupload\" method=\"post`\" enctype=\"multipart/form-data\">\n\t\t<input type=\"text\" name=\"username\"><br>\n\t\t<input type=\"file\" name=\"filename\"><br>\n\t\t<input type=\"submit\" value=\"上传文件\">\n\t</form>\n</body>\n</html>\n```\n&nbsp;&nbsp;这里<font color=\"red\">enctype=\"multipart/form-data\"</font>在使用包含文件上传控件的表单时，必须使用该值。然后进行servlet的编写\n\n```\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.io.IOUtils;\n\npublic class FileuploadServlet2 extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\ttry {\n\n\t\t\t\n\t\t\t//作用：设置缓存文件的大小  设置临时文件存储的位置\n\t\t\tString path_temp = this.getServletContext().getRealPath(\"temp\");\n\t\t\t//1、创建磁盘文件项工厂\n\t\t\t//DiskFileItemFactory factory = new DiskFileItemFactory(1024*1024, new File(path_temp));\n\t\t\tDiskFileItemFactory factory = new DiskFileItemFactory();\n\t\t\tfactory.setSizeThreshold(1024*1024);\n\t\t\tfactory.setRepository(new File(path_temp));\n\t\t\t//2、创建文件上传的核心类\n\t\t\tServletFileUpload upload = new ServletFileUpload(factory);\n\t\t\t//设置上传文件的名称的编码\n\t\t\tupload.setHeaderEncoding(\"UTF-8\");\n\n\t\t\t//ServletFileUpload的API\n\t\t\tboolean multipartContent = upload.isMultipartContent(request);//判断表单是否是文件上传的表单\n\t\t\tif(multipartContent){\n\t\t\t\t//是文件上传的表单\n\t\t\t\t//***解析request获得文件项集合\n\t\t\t\tList<FileItem> parseRequest = upload.parseRequest(request);\n\t\t\t\tif(parseRequest!=null){\n\t\t\t\t\tfor(FileItem item : parseRequest){\n\t\t\t\t\t\t//判断是不是一个普通表单项\n\t\t\t\t\t\tboolean formField = item.isFormField();\n\t\t\t\t\t\tif(formField){\n\t\t\t\t\t\t\t//username=zhangsan\n\t\t\t\t\t\t\tString fieldName = item.getFieldName();\n\t\t\t\t\t\t\tString fieldValue = item.getString(\"UTF-8\");//对普通表单项的内容进行编码\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.println(fieldName+\"----\"+fieldValue);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//当表单是enctype=\"multipart/form-data\"时 request.getParameter相关的方法\n\t\t\t\t\t\t\t//String parameter = request.getParameter(\"username\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//文件上传项\n\t\t\t\t\t\t\t//文件的名\n\t\t\t\t\t\t\tString fileName = item.getName();\n\t\t\t\t\t\t\t//获得上传文件的内容\n\t\t\t\t\t\t\tInputStream in = item.getInputStream();\n\t\t\t\t\t\t\tString path_store = this.getServletContext().getRealPath(\"upload\");\n\t\t\t\t\t\t\tOutputStream out = new FileOutputStream(path_store+\"/\"+fileName);\n\t\t\t\t\t\t\tIOUtils.copy(in, out);\n\t\t\t\t\t\t\tin.close();\n\t\t\t\t\t\t\tout.close();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//删除临时文件\n\t\t\t\t\t\t\titem.delete();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\t//不是文件上传表单\n\t\t\t\t//使用原始的表单数据的获得方式 request.getParameter();\n\t\t\t}\n\t\t} catch (FileUploadException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tdoGet(request, response);\n\t}\n}\n```\n最后上传后只需在你的Tomcat中你所指定的文件夹下就能找到你上传的文件。\n","tags":["apache"],"categories":["Java"]},{"title":"java i++,++i","url":"/2018/05/23/java i++,++i /","content":"## i++\n&nbsp;&nbsp;观察如下代码\n\n    public class demo{\n    \tpublic  static void main(String[] args){\n    \t\tint i = 0;\n    \t\ti = i++;\n    \t\tSystem.out.println(i);\n    \t\t\n    \t}\n    } \n---\n<!-- more -->\n&nbsp;&nbsp;最开始的时候我觉得很糊涂为何输出为0呢？不是应该为1的吗，后来经过javap反编译后了解到其内在.\n&nbsp;&nbsp;反编译后有如下关键代码\n\n- iconst_0(将int型0推入栈顶)\n- istore_1(将栈顶变量存入到第二个本地变量 <font color=\"red\">ps:本地变量索引下标从0开始</font>)\n- iload_1(将本地变量表里第二个变量推入到栈顶)\n- iinc 1,1(将第二个本地变量执行+1)\n- istore_1(将栈顶变量存入到第二个本地变量)\n- iload_1(将本地变量表里第二个变量推入到栈顶)\n- return(返回栈顶)\n\n\n## ++i\n&nbsp;&nbsp;而将i++改为++i后,代码输出为1,,这又是为何,观看下字节码\n\n -  iconst_0\n -  istore_1\n -  iinc 1, 1\n -  iload_1\n -  istore_1\n -  iload_1\n -  return\n\n可以看到i++和++i到底有什么不同,导致最后输出的不同.\n  ","tags":["java基础"],"categories":["Java"]},{"title":"Hibernate one","url":"/2018/05/05/Hibernate one/","content":"## 介绍\n&nbsp;&nbsp;Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用<font color=\"red\">对象编程思维</font>来操纵数据库。<br> &nbsp;&nbsp;Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。\n## 环境搭建\n<!-- more -->\n#### 导包\n&nbsp;&nbsp;首先最基本导入hibernate和jdbc(mysql)所必需的的包导入\n![hibernate_img1](Hibernate one/hibernate1.png)\n\n#### 创建数据库和表\n```\nCREATE TABLE `cst_customer` (\n\t  `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',\n\t  `cust_name` VARCHAR(32) NOT NULL COMMENT '客户名称(公司名称)',\n\t  `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源',\n\t  `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业',\n\t  `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别',\n\t  `cust_linkman` VARCHAR(64) DEFAULT NULL COMMENT '联系人',\n\t  `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话',\n\t  `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话',\n\t  PRIMARY KEY (`cust_id`)\n\t) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n(其实不创建表也行，直接根据bean也导出一张表,后面再提)\n根据表的字段创建出相应bean\n```\npublic class Customer {\n\n\t/*\n\t * CREATE TABLE `cst_customer` (\n\t  `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',\n\t  `cust_name` VARCHAR(32) NOT NULL COMMENT '客户名称(公司名称)',\n\t  `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源',\n\t  `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业',\n\t  `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别',\n\t  `cust_linkman` VARCHAR(64) DEFAULT NULL COMMENT '联系人',\n\t  `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话',\n\t  `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话',\n\t  PRIMARY KEY (`cust_id`)\n\t) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n\t */\n\tprivate Long cust_id;\n\tprivate String cust_name;\n\tprivate String cust_source;\n\tprivate String cust_industry;\n\tprivate String cust_level;\n\tprivate String cust_linkman;\n\tprivate String cust_phone;\n\tprivate String cust_mobile;\n\t//get和set,toString略\n}\n```\n#### 配置文件的配置\n##### 导入xml约束dtd\neclipse导入方法Window=>Preference=>找到 Xml Catalog=>add=>找到dtd导入就行了\n![hibernate_img2](Hibernate one/hibernate2.png)\n##### 创建映射文件\n&nbsp;&nbsp;实体类本身没有持久化能力，而Hibernate需要知道需要知道该实体类映射数据库Hibernate哪个表，以及类中哪个字段，都需要映射文件中配置,在与该类同级下创建一个xxx(与持久化类名一致).hbm.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n   <!-- 配置表与实体对象的关系 -->\n   <!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. -->\n<hibernate-mapping package=\"com.thw.domain\" >\n\t<!--\n\t\tclass元素: 配置实体与表的对应关系的\n\t\t\tname: 完整类名\n\t\t\ttable:数据库表名\n\t -->\n\t<class name=\"Customer\" table=\"cst_customer\" >\n\t\t<!-- id元素:配置主键映射的属性\n\t\t\t\tname: 填写主键对应属性名\n\t\t\t\tcolumn(可选): 填写表中的主键列名.默认值:列名会默认使用属性名\n\t\t\t\ttype(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\n\t\t\t\t\t\t每个类型有三种填法: java类型|hibernate类型|数据库类型\n\t\t\t\tnot-null(可选):配置该属性(列)是否不能为空. 默认值:false\n\t\t\t\tlength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\n\t\t -->\n\t\t<id name=\"cust_id\"  >\n\t\t\t<!-- generator:主键生成策略 -->\n\t\t\t<generator class=\"native\"></generator>\n\t\t</id>\n\t\t<!-- property元素:除id之外的普通属性映射\n\t\t\t\tname: 填写属性名\n\t\t\t\tcolumn(可选): 填写列名\n\t\t\t\ttype(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\n\t\t\t\t\t\t每个类型有三种填法: java类型|hibernate类型|数据库类型\n\t\t\t\tnot-null(可选):配置该属性(列)是否不能为空. 默认值:false\n\t\t\t\tlength(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\n\t\t -->\n\t\t<property name=\"cust_name\" column=\"cust_name\" >\n\t\t\t<!--  <column name=\"cust_name\" sql-type=\"varchar\" ></column> -->\n\t\t</property>\n\t\t<property name=\"cust_source\" column=\"cust_source\" ></property>\n\t\t<property name=\"cust_industry\" column=\"cust_industry\" ></property>\n\t\t<property name=\"cust_level\" column=\"cust_level\" ></property>\n\t\t<property name=\"cust_linkman\" column=\"cust_linkman\" ></property>\n\t\t<property name=\"cust_phone\" column=\"cust_phone\" ></property>\n\t\t<property name=\"cust_mobile\" column=\"cust_mobile\" ></property>\n\t</class>\n</hibernate-mapping>\n```\n##### 创建Hibernate核心配置文件\n###### Hibernate映射文件反映了持久化类和数据库表映射信息，而Hibernate配置文件配置数据库连接和Hibernate运行时所需要各个属性值,在项目的src下面创建一个hibernate.cfg.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n<hibernate-configuration>\n\t<session-factory>\n\n\t\t<!--\n\t\t#hibernate.dialect org.hibernate.dialect.MySQLDialect\n\t\t#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect\n\t\t#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect\n\t\t#hibernate.connection.driver_class com.mysql.jdbc.Driver\n\t\t#hibernate.connection.url jdbc:mysql:///test\n\t\t#hibernate.connection.username gavin\n\t\t#hibernate.connection.password\n\t\t -->\n\t\t <!-- 数据库驱动 -->\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t <!-- 数据库url -->\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql:///xxx</property>\n\t\t <!-- 数据库连接用户名 -->\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t <!-- 数据库连接密码 -->\n\t\t<property name=\"hibernate.connection.password\">xxx</property>\n\t\t<!-- 数据库方言\n\t\t\t不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.\n\t\t\tsql99标准: DDL 定义语言  库表的增删改查\n\t\t\t\t\t  DCL 控制语言  事务 权限\n\t\t\t\t\t  DML 操纵语言  增删改查\n\t\t\t注意: MYSQL在选择方言时,请选择最短的方言.\n\t\t -->\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n\n\n\t\t<!-- #hibernate.show_sql true\n\t\t\t #hibernate.format_sql true\n\t\t-->\n\t\t<!-- 将hibernate生成的sql语句打印到控制台 -->\n\t\t<property name=\"hibernate.show_sql\">true</property>\n\t\t<!-- 将hibernate生成的sql语句格式化(语法缩进) -->\n\t\t<property name=\"hibernate.format_sql\">true</property>\n\t\t<!--\n\t\t## auto schema export  自动导出表结构. 自动建表\n\t\t#hibernate.hbm2ddl.auto create\t\t自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)\n\t\t#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)\n\t\t#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).\n\t\t#hibernate.hbm2ddl.auto validate\t校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.\n\t\t -->\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\t\t<!-- 引入orm元数据\n\t\t\t路径书写: 填写src下的路径\n\t\t -->\n\t\t<mapping resource=\"com/thw/domain/Customer.hbm.xml\" />\n\n\t</session-factory>\n</hibernate-configuration>\n```\n## 测试\n```\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.cfg.Configuration;\nimport org.junit.Test;\n\nimport com.thw.domain.Customer;\n\npublic class hibernateTest {\n\t@Test\n\t//保存客户\n\tpublic void fun1(){\n\t    \t//启动,加载配置信息,Configuration conf = new Configuration().configure()为默认去src下面找到hibernate.cfg.xml加载也可以自定义 Configuration().configure(\"文件路径\")加载.\n\n\t\tConfiguration conf = new Configuration().configure();\n\n\t\t//创建一个SessionFactory工厂\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\t\t//获得Session实例\n\t\tSession session = sessionFactory.openSession();\n\t    //事务操作\n\t\tTransaction tx = session.beginTransaction();\n\t\t//----------------------------------------------\n\t\tCustomer c = new Customer();\n\t\tc.setCust_name(\"google公司\");\n\n\t\tsession.save(c);//执行保存\n\n\t\t//----------------------------------------------\n\t\ttx.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t}\n\t@Test\n\t//查找客户\n\tpublic void fun2(){\n\t\tConfiguration conf = new Configuration().configure();\n\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\n\t\tSession session = sessionFactory.openSession();\n\n\t\tTransaction tx = session.beginTransaction();\n\t\t//----------------------------------------------\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tSystem.out.println(customer);\n\n\t\t//----------------------------------------------\n\t\ttx.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t}\n\t@Test\n\t//更新客户\n\tpublic void fun3(){\n\t\tConfiguration conf = new Configuration().configure();\n\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\n\t\tSession session = sessionFactory.openSession();\n\n\t\tTransaction tx = session.beginTransaction();\n\t\t//----------------------------------------------\n\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tcustomer.setCust_name(\"百度公司\");\n\t\tsession.update(customer);\n\n\t\t//----------------------------------------------\n\t\ttx.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t\tSystem.out.println(customer);\n\t}\n\t@Test\n\t//删除客户\n\tpublic void fun4(){\n\t\tConfiguration conf = new Configuration().configure();\n\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\n\t\tSession session = sessionFactory.openSession();\n\n\t\tTransaction tx = session.beginTransaction();\n\t\t//----------------------------------------------\n\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tsession.delete(customer);\n\n\t\t//----------------------------------------------\n\t\ttx.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t\tSystem.out.println(customer);\n\t}\n}\n```\n## 一些名词解释\n###### SessionFactory:Session工厂对象\n&nbsp;&nbsp;SessionFactory负责Hibernate初始化和建立Session对象,它充当数据储存代理，并负责创建Session对象。创建用了工程对象模式。<font color=\"red\">需注意的是，SessionFactory并不是一个轻量级的</font>，一般情况下一个项目下只需要一个SessionFactory，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。<br>\n&nbsp;&nbsp;SessionFactory在Hibernate中起了一个缓冲作用，Hibernate可以自动生成SQL语句，映射数据和某些可重复利用的数据放在这个缓冲区。同时它还保存数据库配置所有映射关系，维护当前二级缓存。<br>\n&nbsp;&nbsp;SessionFactory具有以下特点：\n\n - 它是线程安全\n - 它是重量级\nSessionFactory维护着一个连接池,若使用第三方连接池C3P0,那么需要手动配置\n```\n<!--配置C3P0-->\n<property name=\"hibernate.connection.provider_class\">org.hibernate.connection.C3P0ConnectionProvider</property>\n<!--连接池可用数据库连接最大数-->\n<property name=\"hibernate.c3p0.max_size\">20</property>\n<!--连接池可用数据库连接最小数-->\n<property name=\"hibernate.c3p0.min_size\">5</property>\n<!--连接过期时间-->\n <property name=\"hibernate.c3p0.timeout\">120</property>\n <!--每3000s去检查空闲连接-->\n<property name=\"hibernate.c3p0.idle_test_period\">3000</property>\n```\n###### Session\n&nbsp;&nbsp;Session负责执行被持久化对象的CRUD操作（该操作完成与数据库的交流，包含许多sql语句）,只有在Session管理下可以进行持久化操作,它有两种方式创建实例:\n\n - Session session = sessionFactory.openSession();\n - Session session = sessionFactory.getCurrentSession();\n\n&nbsp;&nbsp;openSession会获取一个SessionFactory创建的Session实例，需要手动调用close()关闭,而getCurrentSession创建的Session实例会绑定在当前线程，提交或回滚事务自动关闭。<br>\n&nbsp;&nbsp;Session并不是线程安全，多个并发线程同时操作一个Session实例，可能导致Session(方法内部定义就不会出现问题)，所以应该避免多线程共享Session实例，而且它的创建与销毁并不需要消耗太多资源。它还有个一缓存，即Hibernate一级缓存，这个缓存主要存放当前工作单元加载的对象。\nsession提供了大量方法\n\n - save(),update(),和saveOrUpdate()方法，用于增加和修改对象\n - delete()删除对象\n - get()和load()，根据主键查询\n - createQuery()和creatSQLQuery()数据库操作对象\n - createCriteria()条件查询\n\n###### Transaction\n&nbsp;&nbsp;用于管理事务，它常用有两个方法\n\n - commit(),提交session实例\n - rollback(),撤销事务操作\n\n","tags":["hibernate"],"categories":["Java"]},{"title":"Hello World","url":"/2018/05/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n<!-- more -->\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]